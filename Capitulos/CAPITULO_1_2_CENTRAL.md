# üìö TUTORIAL COMPLETO: Entendiendo el C√≥digo de EVCharging

## üéì Este es un curso progresivo para entender TODO el sistema

**Profesor:** Gu√≠a paso a paso  
**Estudiante:** T√∫  
**Objetivo:** Entender cada l√≠nea de c√≥digo

---

# CAP√çTULO 1: CONCEPTOS FUNDAMENTALES

## 1.1 ¬øQu√© es un Sistema Distribuido? (Analog√≠a del Restaurante)

**Imag√≠nate un restaurante:**
- üçΩÔ∏è **Meseros** (EV_Central) ‚Üí Atienden pedidos
- üîå **Puntos de recarga** (EV_CP) ‚Üí Cargan veh√≠culos
- üöó **Clientes** (EV_Driver) ‚Üí Solicitan recarga

**Caracter√≠sticas:**
- Est√°n en **diferentes computadoras** (no en la misma)
- Se **comunican por red** (Internet/red local)
- Trabajan **al mismo tiempo** (en paralelo)

---

## 1.2 ¬øQu√© es un Hilo (Thread)? (Analog√≠a del Chef)

**Imag√≠nate un chef en un restaurante:**

**ANTES (Sin hilos):**
```
Chef cocina Plato 1 ‚Üí Espera terminar ‚Üí Cocina Plato 2 ‚Üí Espera terminar
                      ‚Üë
                 Chef bloqueado
```

**AHORA (Con hilos):**
```
Chef tiene 3 brazos (hilos):
- Brazo 1: Cocina plato principal
- Brazo 2: Cocina ensalada  
- Brazo 3: Prepara postre

TODO AL MISMO TIEMPO ‚úì
```

**En tu c√≥digo:** Central hace M√öLTIPLES cosas al mismo tiempo:
- Escucha sockets de CPs
- Lee mensajes de Kafka
- Muestra el panel
- Lee comandos del usuario

---

## 1.3 ¬øQu√© es Kafka? (Analog√≠a del Buz√≥n)

**Imag√≠nate un buz√≥n postal:**

```
Emisor (Driver) ‚Üí Buz√≥n (Kafka) ‚Üí Receptor (Central)
```

**Kafka = Sistema de mensajer√≠a:**
- Drivers **dejan** mensajes en el buz√≥n (env√≠an)
- Central **lee** mensajes del buz√≥n (recibe)
- Los mensajes **se guardan** aunque nadie los lea a√∫n

**Topics = Diferentes buzones:**
- `driver_requests` ‚Üí Pedidos de drivers
- `cp_telemetry` ‚Üí Datos de CPs
- `driver_notifications` ‚Üí Respuestas para drivers

---

## 1.4 ¬øQu√© son los Sockets? (Analog√≠a del Tel√©fono)

**Socket = Llamada telef√≥nica directa**

```
CP llama a Central ‚Üí Central contesta ‚Üí Hablan
      ‚Üì                    ‚Üì
  [Socket]            [Socket]
```

**Caracter√≠sticas:**
- Conexi√≥n **directa** y **persistente**
- Se mantiene **abierta** mientras hablan
- Central **escucha** (bind + listen)
- CP **se conecta** (connect)
- Intercambian mensajes

---

# CAP√çTULO 2: ANATOM√çA DEL MAIN DE CENTRAL

## 2.1 El Punto de Entrada: `if __name__ == "__main__":`

**L√≠nea 842:** `if __name__ == "__main__":`

**¬øQu√© significa?**
```python
# Si ejecutas: py ev_central.py 8000 127.0.0.1:9092
# Este bloque se ejecuta

# Si importas el archivo desde otro: import EV_Central
# Este bloque NO se ejecuta
```

---

## 2.2 Paso 1: Verificar Argumentos (L√≠neas 842-845)

```python
if len(sys.argv) < 3:
    print("Uso: python ev_central.py <puerto_socket> <kafka_broker_ip:port>")
    sys.exit(1)
```

**¬øQu√© hace?**
- Verifica que hay argumentos suficientes
- `sys.argv` = Lista de argumentos de l√≠nea de comandos
  - `sys.argv[0]` = `ev_central.py`
  - `sys.argv[1]` = `8000` (puerto)
  - `sys.argv[2]` = `127.0.0.1:9092` (kafka)

**Si faltan ‚Üí Sale con error**

---

## 2.3 Paso 2: Extraer Argumentos (L√≠neas 848-850)

```python
SOCKET_PORT = int(sys.argv[1])      # 8000
KAFKA_BROKER = sys.argv[2]           # 127.0.0.1:9092
HOST = '0.0.0.0'                     # Escucha en todas las IPs
```

**¬øQu√© significa `HOST = '0.0.0.0'`?**
- `0.0.0.0` = "Escucha en todas las direcciones IP de esta m√°quina"
- Central acepta conexiones desde:
  - `localhost` (127.0.0.1)
  - IP de la red local
  - Cualquier interfaz de red

---

## 2.4 Paso 3: Variables Compartidas (L√≠neas 852-857)

```python
central_messages = ["CENTRAL system status OK"]
driver_requests = []
```

**¬øQu√© son?**
- **Listas compartidas** entre hilos
- **Visualizaci√≥n:**
  - `central_messages` ‚Üí Lo que muestra el panel
  - `driver_requests` ‚Üí Pedidos de drivers en cola

**¬øPor qu√© son compartidas?**
- M√∫ltiples hilos **escriben** en ellas
- El panel las **lee** constantemente

---

## 2.5 Paso 4: Crear el Producer de Kafka (L√≠neas 859-867)

```python
shared_producer = KafkaProducer(
    bootstrap_servers=[KAFKA_BROKER],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)
shared_producer_ref = shared_producer
```

### ¬øQu√© es un Producer?
**Producer = Enviador de mensajes a Kafka**

**Desglosado:**
```python
# 1. bootstrap_servers=[KAFKA_BROKER]
#    ‚Üí D√≥nde est√° Kafka: 127.0.0.1:9092

# 2. value_serializer=lambda v: json.dumps(v).encode('utf-8')
#    ‚Üí C√≥mo convertir datos a bytes
#    Dict ‚Üí JSON string ‚Üí Bytes
```

### ¬øPor qu√© "shared" (compartido)?
- ‚úÖ Una sola conexi√≥n a Kafka
- ‚úÖ Todos los hilos usan el mismo producer
- ‚úÖ M√°s eficiente que crear uno por hilo

**Sin compartir (malo):**
```
Hilo 1: KafkaProducer() ‚Üí Conexi√≥n 1
Hilo 2: KafkaProducer() ‚Üí Conexi√≥n 2
Hilo 3: KafkaProducer() ‚Üí Conexi√≥n 3
```
**Con compartir (bueno):**
```
Hilo 1 ‚Üí shared_producer ‚Üí 1 Conexi√≥n
Hilo 2 ‚Üí shared_producer
Hilo 3 ‚Üí shared_producer
```

---

## 2.6 Paso 5: Iniciar HILOS en Paralelo

### Hilo 1: kafka_thread (L√≠neas 870-873)
```python
kafka_thread = threading.Thread(
    target=process_kafka_requests, 
    args=(KAFKA_BROKER, central_messages, driver_requests, shared_producer)
)
kafka_thread.daemon = True
kafka_thread.start()
```

**¬øQu√© hace este hilo?**
- **Escucha** mensajes de Kafka
- **Recibe:**** Pedidos de drivers, telemetr√≠a de CPs
- **Procesa:**** Autoriza o deniega pedidos
- **Env√≠a:**** Respuestas a drivers

**¬øPor qu√© `daemon=True`?**
- Si el programa principal termina, este hilo tambi√©n termina
- Sin daemon: El programa no terminar√≠a nunca

**Analog√≠a:** Trabajador que sigue trabajando mientras Central est√° abierto

---

### Hilo 2: network_broadcast_thread (L√≠neas 875-878)
```python
network_broadcast_thread = threading.Thread(
    target=broadcast_network_status, 
    args=(KAFKA_BROKER, shared_producer)
)
network_broadcast_thread.daemon = True
network_broadcast_thread.start()
```

**¬øQu√© hace este hilo?**
- **Cada 5 segundos:**
  1. Obtiene todos los CPs de la BD
  2. Env√≠a el estado a un topic p√∫blico
  3. Los drivers **reciben** este estado

**Ejemplo de mensaje:**
```json
{
  "type": "NETWORK_STATUS_UPDATE",
  "cps": [
    {"id": "MAD-01", "status": "ACTIVADO", "location": "C/ Serrano 10"},
    {"id": "BCN-02", "status": "DESCONECTADO", "location": "Las Ramblas 55"}
  ]
}
```

---

## 2.7 Paso 6: Inicializar Base de Datos (L√≠nea 874)
```python
database.setup_database()
```
**Vamos a ver esta funci√≥n despu√©s...**

---

## 2.8 Paso 7: Marcar CPs como DESCONECTADO (L√≠neas 877-885)

```python
all_cps_on_startup = database.get_all_cps()
if all_cps_on_startup:
    print("[CENTRAL] Restableciendo estado de CPs cargados a DESCONECTADO.")
    for cp in all_cps_on_startup:
        database.update_cp_status(cp['id'], 'DESCONECTADO')
```

**¬øQu√© hace?**
- Lee TODOS los CPs de la BD
- Los marca como DESCONECTADO
- **RAZ√ìN:** Central NO sabe el estado real hasta que el CP se conecte

**Analog√≠a:**
- BD tiene registros antiguos
- Al arrancar, Central asume que est√°n desconectados
- Solo cuando el CP se conecta, se actualiza

---

## 2.9 Paso 8: Iniciar Servidor de Sockets (L√≠neas 886-890)
```python
server_thread = threading.Thread(
    target=start_socket_server, 
    args=(HOST, SOCKET_PORT, central_messages, KAFKA_BROKER)
)
server_thread.daemon = True
server_thread.start()
```

**¬øQu√© hace este hilo?**
- **Escucha en puerto 8000** esperando conexiones
- Cuando un CP se conecta, crea un hilo nuevo para √©l
- **Espera** mensajes de:
  - `REGISTER#CP_ID#LOCATION#PRICE` ‚Üí Registro
  - `FAULT#CP_ID` ‚Üí Aver√≠a
  - `ACK#PARAR` ‚Üí Confirmaci√≥n

**Analog√≠a:** Un portero que deja entrar a quienes llaman

---

## 2.10 Paso 9: Hilo de Comandos del Usuario (L√≠neas 913-917)
```python
input_thread = threading.Thread(target=process_user_input, args=(central_messages,))
input_thread.daemon = True
input_thread.start()
```

**¬øQu√© hace este hilo?**
- **Espera** a que el operador escriba comandos
- **Lee** comandos: `P <CP_ID>`, `R <CP_ID>`, `PT`, `RT`, `Q`
- **Procesa** comandos de PARAR/REANUDAR CPs

**Comandos disponibles:**
- `P <CP_ID>` o `PARAR <CP_ID>` ‚Üí Parar un CP
- `R <CP_ID>` o `REANUDAR <CP_ID>` ‚Üí Reanudar un CP
- `PT` o `PARAR_TODOS` ‚Üí Parar todos los CPs
- `RT` o `REANUDAR_TODOS` ‚Üí Reanudar todos los CPs
- `Q` o `QUIT` ‚Üí Salir

**Ejemplo:**
```
> P MAD-01
[CENTRAL] Comando PARAR enviado a MAD-01
```

---

## 2.11 Paso 10: Hilo de Limpieza de Drivers (L√≠neas 919-923)
```python
cleanup_thread = threading.Thread(target=cleanup_disconnected_drivers)
cleanup_thread.daemon = True
cleanup_thread.start()
```

**¬øQu√© hace este hilo?**
- **Cada 30 segundos:**
  1. Revisa qu√© drivers est√°n conectados
  2. Busca drivers que no han enviado peticiones en 60 segundos
  3. Los elimina de la lista de `connected_drivers`
  4. Libera sus asignaciones de CPs

**Por qu√© es necesario:**
- Si un driver se desconecta bruscamente (cae el programa)
- Central no se enterar√≠a sin este hilo
- Se limpia autom√°ticamente la lista de drivers activos

---

## 2.12 Paso 11: Panel de Monitorizaci√≥n (L√≠nea 925)
```python
display_panel(central_messages, driver_requests)
```

**¬øQu√© hace?**
- Bucle infinito que muestra el estado del sistema
- Se refresca cada 2 segundos
- **Muestra:**
  - Tabla de CPs (con colores)
  - Drivers conectados
  - Pedidos en cola
  - Mensajes del sistema
  - Comandos disponibles

**Nota:** Es la √∫nica funci√≥n que NO corre en hilo
- Bloquea el programa principal
- Mantiene Central "vivo" y mostrando el panel

---

# RESUMEN DEL ARRANQUE DE CENTRAL

```
Paso 1: Verifica argumentos (l√≠nea 847)
Paso 2: Extrae puerto y Kafka broker (l√≠neas 853-855)
Paso 3: Crea variables compartidas (l√≠neas 858-859)
Paso 4: Crea producer de Kafka compartido (l√≠neas 862-867)
Paso 5.1: Inicia hilo para consumir mensajes de Kafka (l√≠neas 876-878)
Paso 5.2: Inicia hilo para anunciar estado de red (l√≠neas 885-887)
Paso 6: Configura base de datos (l√≠nea 891)
Paso 7: Marca CPs como DESCONECTADO (l√≠neas 896-900)
Paso 8: Inicia hilo servidor de sockets (l√≠neas 909-911)
Paso 9: Inicia hilo de comandos del usuario (l√≠neas 915-917)
Paso 10: Inicia hilo de limpieza de drivers (l√≠neas 921-923)
Paso 11: Muestra panel (bloquea aqu√≠) (l√≠nea 937)
```

**Total de hilos iniciados:**
- ‚úÖ `kafka_thread` - Consume mensajes de Kafka
- ‚úÖ `network_broadcast_thread` - Anuncia estado de red
- ‚úÖ `server_thread` - Escucha sockets de CPs
- ‚úÖ `input_thread` - Lee comandos del usuario
- ‚úÖ `cleanup_thread` - Limpia drivers desconectados
- ‚è∏Ô∏è Panel se ejecuta en hilo principal (bloquea)

---

---

# CAP√çTULO 3: Sistema de Sockets ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_3_SOCKETS.md`

**Contenido:**
- ‚úÖ ¬øQu√© es un Socket?
- ‚úÖ Funci√≥n `start_socket_server()` - Portero que escucha
- ‚úÖ Funci√≥n `handle_client()` - Atiende cada CP
- ‚úÖ Funci√≥n `process_socket_data2()` - Procesa mensajes
- ‚úÖ Ejemplo pr√°ctico completo
- ‚úÖ Conceptos de Locks

---

# CAP√çTULO 4: Sistema de Kafka ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_4_KAFKA.md`

**Contenido:**
- ‚úÖ Topics: driver_requests, cp_telemetry, driver_notifications, network_status
- ‚úÖ Producers y Consumers en Central, Driver y Engine
- ‚úÖ Serializaci√≥n/Deserializaci√≥n JSON
- ‚úÖ Flujos completos: Solicitud, Consumo, Ticket, Aver√≠a
- ‚úÖ Producer compartido en Central
- ‚úÖ Diagrama de flujo resumen

---

# CAP√çTULO 5: Base de Datos SQLite ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_5_BASE_DATOS.md`

**Contenido:**
- ‚úÖ SQLite embebido: archivo √∫nico ev_charging.db
- ‚úÖ 3 tablas: charging_points, drivers, transactions
- ‚úÖ Thread safety con db_lock
- ‚úÖ Estados de CPs: DESCONECTADO ‚Üí ACTIVADO ‚Üí RESERVADO ‚Üí SUMINISTRANDO
- ‚úÖ Funciones CRUD: register_cp, update_cp_status, get_all_cps
- ‚úÖ Gesti√≥n de consumo: update_cp_consumption, clear_cp_consumption
- ‚úÖ Integraci√≥n con panel de Central
- ‚úÖ Manejo de errores y fallback

---

# CAP√çTULO 6: Panel de Monitorizaci√≥n ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_6_PANEL.md`

**Contenido:**
- ‚úÖ Estructura y fuentes de datos del panel
- ‚úÖ Colores ANSI por estado (incluye RESERVADO)
- ‚úÖ Secciones: CPs, Drivers conectados, Peticiones, Mensajes, Comandos
- ‚úÖ Relaci√≥n con BD y Kafka
- ‚úÖ Concurrencia: solo lectura + locks donde aplica
- ‚úÖ Posibles mejoras

---

# CAP√çTULO 7: Locks y Sincronizaci√≥n ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_7_LOCKS.md`

**Contenido:**
- ‚úÖ Qu√© es threading.Lock y por qu√© se necesita
- ‚úÖ 3 locks principales: active_cp_lock, status_lock, db_lock
- ‚úÖ Patr√≥n `with` para adquisici√≥n/liberaci√≥n autom√°tica
- ‚úÖ Casos de uso reales en Central, Engine y BD
- ‚úÖ Condiciones de carrera y c√≥mo evitarlas
- ‚úÖ Buenas pr√°cticas: granularidad, duraci√≥n m√≠nima
- ‚úÖ Ejemplos completos de flujos de autorizaci√≥n
- ‚úÖ Tabla resumen de locks por m√≥dulo

---

# CAP√çTULO 8: Driver - Aplicaci√≥n del Conductor ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_8_DRIVER.md`

**Contenido:**
- ‚úÖ Arquitectura del Driver: 4 hilos concurrentes
- ‚úÖ Comunicaci√≥n Kafka: Producer + 2 Consumers
- ‚úÖ Estado compartido: network_status, active_charge_info
- ‚úÖ Panel visual din√°mico con estado de recarga
- ‚úÖ Comandos: SOLICITAR (manual), BATCH (autom√°tico)
- ‚úÖ Filtrado inteligente de mensajes
- ‚úÖ Manejo de errores y interrupciones
- ‚úÖ Flujo completo de recarga paso a paso
- ‚úÖ Integraci√≥n con Central y Kafka
- ‚úÖ Ejemplos de uso y buenas pr√°cticas

---

# CAP√çTULO 9: Engine - Motor del Punto de Recarga ‚úÖ COMPLETADO

üìÑ **Ver archivo:** `CAPITULO_9_ENGINE.md`

**Contenido:**
- ‚úÖ Arquitectura del Engine: 3 hilos concurrentes
- ‚úÖ Comunicaci√≥n: Sockets con Monitor, Kafka con Central
- ‚úÖ Estado compartido: ENGINE_STATUS con locks
- ‚úÖ Simulaci√≥n de recarga con telemetr√≠a cada segundo
- ‚úÖ Comandos: FAIL, RECOVER, INIT, END
- ‚úÖ Problemas identificados: panel duplicado, funciones no usadas
- ‚úÖ Flujo completo de autorizaci√≥n e inicio de recarga
- ‚úÖ Integraci√≥n con Monitor y Central
- ‚úÖ Ejemplos de uso y c√≥digo optimizado propuesto

---

# PR√ìXIMOS CAP√çTULOS
- Cap√≠tulo 10: Flujo Completo del Sistema (end-to-end)
- Cap√≠tulo 11: Troubleshooting y Debugging
- Cap√≠tulo 12: Mejoras y Optimizaciones

¬øCon cu√°l seguimos? üéì
